// 1. Массивы в JS являются "неправельными" т.к как эта структура должна хранить в себе строго упорядоченный список (index: значение). В JS к такой структуре  как массивы относится много сущностей (как сами массивы с полным набором методв) так и живые коллекции, псевдо массивы, связанные списки, структура данных map (в которых ключём может быть что угодно). А так же массивы могут денамически менять длинну а по задумке они должны быть не изменны.  

// 2.
function logger(/* параметры */) {
  console.log(`I output only external context: ${this.item}`);
}
const obj = {
  item: "some value" 
};

// logger.call(obj); // - привязывает контекст и сразу вызывает функцию. Так же в случаии передачи параметров принимает их в качестве строки
// logger.apply(obj); // - привязывает контекст и сразу вызывает функцию. Так же в случаии передачи параметров принимает их в качестве массива
// logger.bind(obj)(); // - привязывает жестко контекст к новой функции

// 3.1
const numbers = [1, 2, 3, 4, 5]; 
// складываем числа методо reduse можно просто циклом.
function sumArr(arr) {
  return arr.reduce((sum, current) => sum + current)
}
console.log(sumArr(numbers));
// -----

const strArray = ['Hello', 'world','in', 'JS']; 
// Склееваем в строку с помощью встроенного метода join 
function joinArr(arr) {
  return arr.join(' ');
}
console.log(joinArr(strArray));
// -----

// функция метод sort сортирует массив как строки (эта проблема решается другой фунцией compareNum). Т.к массив у нас по итогу отсортирован то можно просто вязять первый и последний элемент и вывести его в качестве массива. 
function getMinMaxNum(arr) {
  arr.sort(compareNum);

  function compareNum(a, b) {
    return a - b;
  }
  return [arr[0], arr[arr.length - 1]];
}

console.log(getMinMaxNum(numbers));

// 3.2 
// в стеке данные представляют собой список элементов построенный по принципу LIFO (Можно представить как не мытые тараеки в раковине, когда мы начинаем мыть посуду мы берем ту которая находится на самом верху (последняя пришла первая ушла))
const imitateStack = []; 
console.log(imitateStack.length); // проверели массив на пустоту
imitateStack.push(1); //складываем числа в конец массива
imitateStack.push(2); //складываем числа в конец массива
imitateStack.push(3); //складываем числа в конец массива
imitateStack.pop(); // удаляем число
console.log(imitateStack);

// 3.3
// Queue имеет обратный принцип в отличии от стека FIFO (первый пришол первый ушел). На практике думаю что такая релизация с методами unshift и shift редко используется т.к это вызывает лишнюю нагрузку на девайс который будет обрабатывать код. Т.к когда мы меняем индекс первого номера в массиве, нам нужно поменять индекс всем остальным которые идут за ним (с push и pop такого не будет).
const imitateQueue = []; 
console.log(imitateQueue.length); // проверели массив на пустоту
imitateQueue.unshift(1); //складываем числа в начало массива
imitateQueue.unshift(2); //складываем числа в начало массива
imitateQueue.unshift(3); //складываем числа в начало массива
imitateQueue.shift(); // удаляем первое число
console.log(imitateQueue);


 